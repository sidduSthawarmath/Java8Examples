Lambda expression:
----------------------------------------
Lambda expression is 
	- Not having modifiers(such as public, private & protected)
	- Not having return type(void, int, float)
	- Not having even function name also

Example : 
    public void add(int a, int b)
	    {
	    retun a+b;
	    }
    
    In Lambda exp:
    (a,b)->a+b;
 
    
    
    
Functional interface:
----------------------------- 
 Functional interface is a interface it should have only one abstract method
 and it may or may not have static or default methods. 
 (Example: Runnable, Comparator, Comparable)
	 - @FunctionalInterface indicate that interface should rules of the functional
		interface
     - Functional interface should have only One abstract method
     - It may have N number of default and static methods
     - Functional interface have extends of some other interface also but
       condition is that if its parent already have One abstract methods
       then it should not have abstract method.
       
       
  Example :
  
		public class FunctionalInterfaceExample {
			public static void main(String[] args) {
				Message message = (name) -> System.out.println("Welcome to java8 " + name);
				message.welcomeMsg("Siddu");
			}
		}
				
		@FunctionalInterface
		interface Message {
			public void welcomeMsg(String name);
		}
       
       output:
       Welcome to java8 Siddu
       
       
 
 Default Methods(Virtual extension methods/Defender methods):
 ------------------
 Until JDK 1.7 Version
 	void m1();
 	public void m1();
 	abstract void m1();
 	public abstract void m1();
 	
 	
In JDK 1.8 version onwards
	Related to methods:
	    in jdk1.8 : default methods are allowed and static methods are also allowed
	    in jdk1.9 : private methods are also allowed
	    
	Related to variables:
	     public static final always in JDK 1.7, 1.8 & 1.9 also
	
	
	 Without affecting implementation classes, if we want to add new
	 method to the interface then we should go for default method concept.
	 
	 
	 Example:
	 		interface Interf {
				default void m1() {
					System.out.println("This is default method");
				}
			}
			
			public class DefaultMethodsExample implements Interf {
				public void m1() {
					System.out.println("This is default method overrided method");
				}
				public static void main(String[] args) {
					Interf interf = new DefaultMethodsExample();
					interf.m1();
				}
			}
	 
	 		output:
	        This is default method overrided method
	        
	        
	      Note:
	         - default is not a modifier
	         - While overriding default method child class method should have modifier
	         	as public only otherwise it gives compilation error
	         - We can't declare or define default method as methods of the object class
	           (Example : hashcode(), wait(), toString() etc)
	           it gives compilation error because child classes already having the
	           these method from Object class so it will not take from interface.
	     
	     
     If default method are present in two interfaces with same name and child class
     implements both interfaces then child class must override default method.
     if we need to call any default method of the interface in child class
     then we can use syntax like
     
     <inetrfaceName>.super.<methodName>  
      
      interface A	                  interface B           
	   m1(){ Sysout("A method") }            m1(){Sysout("B method")}
	       \                           /
	        \                         /
	          \                      /
		             interface c
		              m1()
		              {
		              A.super.m1();  //prints as output "A method"
		              B.super.m1();  //Prints as output "B method"
		              }
		              
		              
static methods
------------------------------
  - class vs interface
       interface is not heavy weight component as compared to class because 
       it never contains constructor block, static block, instance block
       
  - static method are no where related to object. In such cases instead of going class
  we can go for interface concept
     
     interface StaticMethodDemo {
			public static void display() {
				System.out.println("This is static method");
			}
		}

	public class StaticMethodsExample implements StaticMethodDemo {
		public static void main(String[] args) {
			StaticMethodDemo.display();
				}
		}
		
    - In above example static method belongs to the interface it will not inherited to
      the child class. So if we want to call that method means we must and should use
      <interfaceName>.<staticMethodName> there is no other ways.
      
  
 Predefined functional interfaces(It should have only one abstract method)
 -------------------------------------
 	Predicate
 	Function
 	Consumer
 	Producer
      Two argument predefined functional interfaces:
      -----------------------------------------------
      BiPredicate
      BiFunction
      BiConsumer
      BiProducer
      
      Primitive predefined functional interfaces:
      ---------------------------------------------
	  IntPredicate
	  IntFunction
	  IntConsumer
	  ...
	  
	  
Predicate :
----------	
   Predicate is used for check the condition.
   Method :
       public boolean test(T t);
     
     Example 1: check even or odd number
		public class PredicateExample {
			public static void main(String[] args) {
				Predicate<Integer> predicate = num -> num % 2 == 0;
				System.out.println("10 is even number : " + predicate.test(10));
				System.out.println("5 is even number : " + predicate.test(5));
			}
		}
     
     output:
        10 is even number : true
		5 is even number : false


    Example 2: check employee salary is greate than 50k and gender is Male
            Predicate<Employee> predicate = e -> e.getSalary()>50000 && e.getGender().equals("M");
            predicate.test(e);      
   
   
     Predicate Joining:
     ------------------
     We can combine multiple of predicate to to check the condition -> predicate joining
     
     Example:
    	predicate p1 -> Check the number is even or not
    	predicate p2- > checks the number is greater than 20
       
       we can join as:
        'and' is check both should be true
         	p1.and(p2).test(10);
        
        'or' check if any one of the true
        	p1.or(p2).test(10);
        
        'negate' gives the reverse result
        	p1.negate()
        
   
   
	  Example :
			 public class PredicateJoiningExample {
					public static void main(String[] args) {
						int[] num = { 10, 5, 12, 6, 21 };
						// Number is even predicate
						Predicate<Integer> evenNumCheck = n -> n % 2 == 0;
				
						// Num is greater than 10 predicate
						Predicate<Integer> numGreaterThan10 = n -> n > 10;
				
						for (int n : num) {
				
							// 'and' Predicate joining
							if (evenNumCheck.and(numGreaterThan10).test(n)) {
								System.out.println("Number is even and greater than 10:" + n);
							}
				
							// 'or' Predicate joining
							if (evenNumCheck.or(numGreaterThan10).test(n)) {
								System.out.println("Number may be even or greater than 10:" + n);
							}
						}
					}
				}
	  
	  	
		   output:
		   			Number is even and greater than 10:12
					Number may be even or greater than 10:10
					Number may be even or greater than 10:12
					Number may be even or greater than 10:6
					Number may be even or greater than 10:21
					       
       
       
Function:
--------------
  we need to pass some input and perform some operations and produce some result but result should not be
  boolean(Because for boolean result we have Predicate functional result)  then we should go for function.
  
  Method:
     public R apply(T t);
            
  Example 1:
   
		//Print string into upper case
		//Print string length
		//Print number as its square
		public class FunctionExm {
			public static void main(String[] args) {
		
				Function<String, String> upperCaseFunction = letter -> letter.toUpperCase();
				System.out.println("Print java in upper case letter : " + upperCaseFunction.apply("Siddu"));
		
				Function<String, Integer> findLengthFunction = letter -> letter.length();
				System.out.println("Number of letters 'Welcome to java' :" + findLengthFunction.apply("Welcome to java"));
		
				Function<Integer, Integer> squareNumFunction = num -> num * num;
				System.out.println("Square of '5' :" + squareNumFunction.apply(5));
		
			}
		
		}
		
   	    output:
   	     Print java in upper case letter : SIDDU
		 Number of letters 'Welcome to java' :15
		 Square of '5' :25
   	     
   	     
   	     
   	 Example 2: Find grade of the student
   	 
		 public class GradeOfStudent {
			public static void main(String[] args) {
		
				// Predicate Declarations
				Predicate<Integer> firstClass = marks -> marks >= 60;
				Predicate<Integer> secondClass = marks -> marks >= 50;
				Predicate<Integer> thirdClass = marks -> marks >= 35;
		
				// Function declaration
				Function<Student, String> findGradeFunction = student -> {
					if (firstClass.test(student.marks)) {
						return "FirstClass";
					} else if (secondClass.test(student.marks)) {
						return "secondClass";
					} else if (thirdClass.test(student.marks)) {
						return "thirdClass";
					} else {
						return "Fail";
					}
		
				};
		
				// Finding the Grade of the student
				System.out.println("Result: " + findGradeFunction.apply(new Student("Siddu", 90)));
		
			}
		
		}
		
		class Student {
			String name;
			int marks;
			public Student(String name, int marks) {
				this.name = name;
				this.marks = marks;
			}
		}
		   	 	    
        
        output:
        	    Result: FirstClass
       
       
     
   Function chaining:
   -----------------
    	Two functions can be combined to form more complex function.
       
       i. f1.andThen(f2).apply(i);
       	   Here f1 function first executed and result will be used as input for f2 function 
       
       ii. f1.compose(f2).apply(i);
            Here f2 function first executed and result will be used as input for f1 function
            
       
       Example :
				public class FunctionChainingExample {
					public static void main(String[] args) {
						Function<Integer, Integer> multiflyBy2Fun = num -> num * 2;
						Function<Integer, Integer> squareNum = num -> num * num;
						
						//Here f1 function first executed and result will be used as input for f2 function 
						System.out.println("Example of andThen :"+multiflyBy2Fun.andThen(squareNum).apply(2));
					
						//Here f2 function first executed and result will be used as input for f1 function
						System.out.println("Example of compose :"+multiflyBy2Fun.compose(squareNum).apply(2));
						
					}
				}     
          
           output :
       				Example of andThen :16
					Example of compose :8
       
       
       
       
       
       
       
       
       
       
       
       
       